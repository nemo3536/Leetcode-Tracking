## 203. Remove Linked List Elements

**Link:** [203. Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/description/)
```
Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.

Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]

Example 2:

Input: head = [], val = 1
Output: []

Example 3:
Input: head = [7,7,7,7], val = 7
Output: []

Constraints:

The number of nodes in the list is in the range [0, 104].
1 <= Node.val <= 50
0 <= val <= 50
```
**Thoughts:** 

 - Dummy head: to avoid edge cases

**Solutions:** 
![Uploading 41a1a55a2cbd5ed3f610bc30e5cfda9.jpgâ€¦]()

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        while (head && head->val == val) head = head->next;
        if (!head) return head;

        ListNode* slow = head;
        ListNode* fast = head->next;

        while(fast) {
            if (fast->val == val) {
                slow->next = fast->next;
                fast = fast->next;
            } else {
                slow = slow->next;
                fast = fast->next;
            }
        }
        return head;
    }
};
```    

**Time Complexity:**  O(N)

**Spcae Complexity:**  O(1)


## 707. Design Linked List

**Link:** [707. Design Linked List](https://leetcode.com/problems/design-linked-list/description/)

**Thoughts:** 

 - Need to create a Node object to store `.val` and `.size`
 - Need `.size` to store the size
 - Use Dummy Head `curr = self.head.next`

**Solution:**
```
class Node(object):
    def __init__(self,x=0):
        self.val = x
        self.next = None

class MyLinkedList:

    def __init__(self):
        self.head = Node()
        self.size = 0
        
    def get(self, index: int) -> int:
        if index < 0 or index > self.size - 1:
            return -1
        curr = self.head.next
        for i in range(index):
            curr = curr.next
        return curr.val
        

    def addAtHead(self, val: int) -> None:
        newNode = Node(val)
        newNode.next = self.head.next
        self.head.next = newNode
        self.size += 1

    def addAtTail(self, val: int) -> None:
        newNode = Node(val)
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = newNode
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0:
            self.addAtHead(val)
            return
        elif index == self.size:
            self.addAtTail(val)
            return
        elif index > self.size:
            return

        newNode = Node(val)
        curr = self.head
        for i in range(index):
            curr = curr.next
        newNode.next = curr.next
        curr.next = newNode
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:

        if index < 0 or index > self.size - 1:
            return
        curr = self.head
        for i in range(index):
            curr = curr.next
        curr.next = curr.next.next
        self.size -= 1
```    



## 206. Reverse Linked List

**Link:** [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)

**Thoughts:** 

 - Both iteratively and recursively
 - Recursively: 1. the definition of the recursive function 2. remember the base case
   ![image](https://user-images.githubusercontent.com/69004164/206819153-bfa5a9e9-3c56-4ec2-8035-a55562b7f584.png)
   ![image](https://user-images.githubusercontent.com/69004164/206819179-6ce89750-1837-4f7d-98c0-88ce0aa27972.png)
   ![image](https://user-images.githubusercontent.com/69004164/206819186-41b40fa0-114b-4c5c-82c4-e66692e94178.png)
   ![image](https://user-images.githubusercontent.com/69004164/206819193-89a7d8e2-4661-4160-a8d6-10f6175db167.png)


**Solutions:** 

Iteratively: 
```
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        if not head or not head.next: return head

        curr = head
        prev = None
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt
        return prev
```
**Time Complexity:**  O(n)

**Spcae Complexity:**  O(1)

Recursively: 
```
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next: return head

        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None

        return last
```
**Time Complexity:**  O(n)

**Spcae Complexity:**  O(n)
